{"version":3,"file":"test-utils.js","sources":["../../src/transform/test-utils.ts"],"sourcesContent":["import fs from \"fs\";\nimport {\n\ttype Source,\n\ttype TransformContext,\n\ttype Transformer,\n\ttype TransformerChainedResult,\n} from \"html-validate\";\n\n/* eslint-disable-next-line import/no-extraneous-dependencies -- this is the package itself */\nexport {\n\ttype Source,\n\ttype Transformer,\n\ttype TransformerResult,\n\ttype TransformerChainedResult,\n} from \"html-validate\";\n\nfunction isIterable(\n\tvalue: Source | Iterable<Source | Promise<Source>>,\n): value is Iterable<Source | Promise<Source>> {\n\treturn Symbol.iterator in value;\n}\n\n/**\n * Helper function to call a transformer function in test-cases.\n *\n * @public\n * @param fn - Transformer function to call.\n * @param filename - Filename to read data from. Must be readable.\n * @param chain - If set this function is called when chaining transformers. Default is pass-thru.\n */\nexport function transformFile(\n\tfn: Transformer,\n\tfilename: string,\n\tchain?: (source: Source, filename: string) => TransformerChainedResult,\n): Promise<Source[]> {\n\tconst data = fs.readFileSync(filename, \"utf-8\");\n\tconst source: Source = {\n\t\tfilename,\n\t\tline: 1,\n\t\tcolumn: 1,\n\t\toffset: 0,\n\t\tdata,\n\t};\n\treturn transformSource(fn, source, chain);\n}\n\n/**\n * Helper function to call a transformer function in test-cases.\n *\n * @public\n * @param fn - Transformer function to call.\n * @param data - String to transform.\n * @param chain - If set this function is called when chaining transformers. Default is pass-thru.\n */\nexport function transformString(\n\tfn: Transformer,\n\tdata: string,\n\tchain?: (source: Source, filename: string) => TransformerChainedResult,\n): Promise<Source[]> {\n\tconst source: Source = {\n\t\tfilename: \"inline\",\n\t\tline: 1,\n\t\tcolumn: 1,\n\t\toffset: 0,\n\t\tdata,\n\t};\n\treturn transformSource(fn, source, chain);\n}\n\n/**\n * Helper function to call a transformer function in test-cases.\n *\n * @public\n * @param fn - Transformer function to call.\n * @param data - Source to transform.\n * @param chain - If set this function is called when chaining transformers. Default is pass-thru.\n */\nexport async function transformSource(\n\tfn: Transformer,\n\tsource: Source,\n\tchain?: (source: Source, filename: string) => TransformerChainedResult,\n): Promise<Source[]> {\n\tconst defaultChain = (source: Source): Iterable<Source> => [source];\n\tconst context: TransformContext = {\n\t\thasChain: /* istanbul ignore next */ () => true,\n\t\tchain: chain ?? defaultChain,\n\t};\n\tconst result = await fn.call(context, source);\n\tif (isIterable(result)) {\n\t\treturn await Promise.all(Array.from(result));\n\t} else {\n\t\treturn [result];\n\t}\n}\n"],"names":["fs","source"],"mappings":";;;;;;;;AAgBA,SAAS,WACR,KAC8C,EAAA;AAC9C,EAAA,OAAO,OAAO,QAAY,IAAA,KAAA;AAC3B;AAUgB,SAAA,aAAA,CACf,EACA,EAAA,QAAA,EACA,KACoB,EAAA;AACpB,EAAA,MAAM,IAAO,GAAAA,mBAAA,CAAG,YAAa,CAAA,QAAA,EAAU,OAAO,CAAA;AAC9C,EAAA,MAAM,MAAiB,GAAA;AAAA,IACtB,QAAA;AAAA,IACA,IAAM,EAAA,CAAA;AAAA,IACN,MAAQ,EAAA,CAAA;AAAA,IACR,MAAQ,EAAA,CAAA;AAAA,IACR;AAAA,GACD;AACA,EAAO,OAAA,eAAA,CAAgB,EAAI,EAAA,MAAA,EAAQ,KAAK,CAAA;AACzC;AAUgB,SAAA,eAAA,CACf,EACA,EAAA,IAAA,EACA,KACoB,EAAA;AACpB,EAAA,MAAM,MAAiB,GAAA;AAAA,IACtB,QAAU,EAAA,QAAA;AAAA,IACV,IAAM,EAAA,CAAA;AAAA,IACN,MAAQ,EAAA,CAAA;AAAA,IACR,MAAQ,EAAA,CAAA;AAAA,IACR;AAAA,GACD;AACA,EAAO,OAAA,eAAA,CAAgB,EAAI,EAAA,MAAA,EAAQ,KAAK,CAAA;AACzC;AAUsB,eAAA,eAAA,CACrB,EACA,EAAA,MAAA,EACA,KACoB,EAAA;AACpB,EAAA,MAAM,YAAe,GAAA,CAACC,OAAqC,KAAA,CAACA,OAAM,CAAA;AAClE,EAAA,MAAM,OAA4B,GAAA;AAAA,IACjC,QAAA;AAAA;AAAA,MAAqC,MAAM;AAAA,KAAA;AAAA,IAC3C,OAAO,KAAS,IAAA;AAAA,GACjB;AACA,EAAA,MAAM,MAAS,GAAA,MAAM,EAAG,CAAA,IAAA,CAAK,SAAS,MAAM,CAAA;AAC5C,EAAI,IAAA,UAAA,CAAW,MAAM,CAAG,EAAA;AACvB,IAAA,OAAO,MAAM,OAAQ,CAAA,GAAA,CAAI,KAAM,CAAA,IAAA,CAAK,MAAM,CAAC,CAAA;AAAA,GACrC,MAAA;AACN,IAAA,OAAO,CAAC,MAAM,CAAA;AAAA;AAEhB;;;;;;"}