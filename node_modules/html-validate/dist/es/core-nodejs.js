import path from 'node:path';
import { a as ConfigError, U as UserError, b as ConfigLoader, O as isThenable, C as Config, L as compatibilityCheckImpl, v as version } from './core.js';
import fs from 'node:fs';
import fs$1 from 'node:fs/promises';
import { createRequire } from 'node:module';
import kleur from 'kleur';

function requireUncached(require, moduleId) {
  const filename = require.resolve(moduleId);
  const m = require.cache[filename];
  if (m?.parent) {
    const { parent } = m;
    for (let i = parent.children.length - 1; i >= 0; i--) {
      if (parent.children[i].id === filename) {
        parent.children.splice(i, 1);
      }
    }
  }
  delete require.cache[filename];
  return require(filename);
}

const legacyRequire = createRequire(import.meta.url);
			const importResolve = (specifier) => {
				return new URL(import.meta.resolve(specifier));
			};

let cachedRootDir = null;
function determineRootDirImpl(intial, fs2) {
  let current = intial;
  while (true) {
    const search = path.join(current, "package.json");
    if (fs2.existsSync(search)) {
      return current;
    }
    const child = current;
    current = path.dirname(current);
    if (current === child) {
      break;
    }
  }
  return intial;
}
function determineRootDir() {
  if (cachedRootDir === null) {
    cachedRootDir = determineRootDirImpl(process.cwd(), fs);
  }
  return cachedRootDir;
}

function expandRelativePath(value, { cwd }) {
  if (typeof value === "string" && value.startsWith(".")) {
    return path.normalize(path.join(cwd, value));
  } else {
    return value;
  }
}

function isRequireError(error) {
  return Boolean(error && typeof error === "object" && "code" in error);
}
function isTransformer$1(value) {
  return typeof value === "function";
}
function cjsResolver(options = {}) {
  const rootDir = options.rootDir ?? determineRootDir();
  function internalRequire(id, { cache }) {
    const moduleName = id.replace("<rootDir>", rootDir);
    try {
      if (cache) {
        return legacyRequire(moduleName);
      } else {
        return requireUncached(legacyRequire, moduleName);
      }
    } catch (err) {
      if (isRequireError(err) && err.code === "MODULE_NOT_FOUND") {
        return null;
      }
      throw err;
    }
  }
  return {
    name: "nodejs-resolver",
    resolveElements(id, options2) {
      return internalRequire(id, options2);
    },
    resolveConfig(id, options2) {
      const configData = internalRequire(id, options2);
      if (!configData) {
        return null;
      }
      const cwd = path.dirname(id);
      const expand = (value) => expandRelativePath(value, { cwd });
      if (Array.isArray(configData.elements)) {
        configData.elements = configData.elements.map(expand);
      }
      if (Array.isArray(configData.extends)) {
        configData.extends = configData.extends.map(expand);
      }
      if (Array.isArray(configData.plugins)) {
        configData.plugins = configData.plugins.map(expand);
      }
      return configData;
    },
    resolvePlugin(id, options2) {
      return internalRequire(id, options2);
    },
    resolveTransformer(id, options2) {
      const mod = internalRequire(id, options2);
      if (!mod) {
        return null;
      }
      if (isTransformer$1(mod)) {
        return mod;
      }
      if (mod.transformer) {
        throw new ConfigError(
          `Module "${id}" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`
        );
      }
      throw new ConfigError(`Module "${id}" is not a valid transformer.`);
    }
  };
}
function nodejsResolver(options = {}) {
  return cjsResolver(options);
}

function importFunction(id) {
  return import(id);
}

async function getModuleName(id, { cache, rootDir }) {
  const moduleName = id.replace("<rootDir>", rootDir);
  const url = importResolve(moduleName);
  if (url.protocol !== "file:") {
    return url;
  }
  if (cache) {
    return url;
  } else {
    const stat = await fs$1.stat(url);
    url.searchParams.append("mtime", String(stat.mtime.getTime()));
    return url;
  }
}
function isImportError(error) {
  return Boolean(error && typeof error === "object" && "code" in error);
}
async function internalImport(id, rootDir, { cache }) {
  if (id.endsWith(".json")) {
    const content = await fs$1.readFile(id, "utf-8");
    return JSON.parse(content);
  }
  try {
    const url = await getModuleName(id, { cache, rootDir });
    if (url.protocol !== "file:") {
      return null;
    }
    const moduleName = url.toString();
    const { default: defaultImport } = await importFunction(moduleName);
    if (!defaultImport) {
      throw new UserError(`"${id}" does not have a default export`);
    }
    return defaultImport;
  } catch (err) {
    if (isImportError(err) && err.code === "MODULE_NOT_FOUND" && !err.requireStack) {
      return null;
    }
    throw err;
  }
}

function isTransformer(value) {
  return typeof value === "function";
}
function esmResolver(options = {}) {
  const rootDir = options.rootDir ?? determineRootDir();
  return {
    name: "esm-resolver",
    resolveElements(id, options2) {
      return internalImport(id, rootDir, options2);
    },
    async resolveConfig(id, options2) {
      const configData = await internalImport(id, rootDir, options2);
      if (!configData) {
        return null;
      }
      const cwd = path.dirname(id);
      const expand = (value) => expandRelativePath(value, { cwd });
      if (Array.isArray(configData.elements)) {
        configData.elements = configData.elements.map(expand);
      }
      if (Array.isArray(configData.extends)) {
        configData.extends = configData.extends.map(expand);
      }
      if (Array.isArray(configData.plugins)) {
        configData.plugins = configData.plugins.map(expand);
      }
      return configData;
    },
    resolvePlugin(id, options2) {
      return internalImport(id, rootDir, options2);
    },
    async resolveTransformer(id, options2) {
      const mod = await internalImport(id, rootDir, options2);
      if (!mod) {
        return null;
      }
      if (isTransformer(mod)) {
        return mod;
      }
      if (mod.transformer) {
        throw new ConfigError(
          `Module "${id}" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`
        );
      }
      throw new ConfigError(`Module "${id}" is not a valid transformer.`);
    }
  };
}

function findConfigurationFiles(fs2, directory) {
  return ["json", "mjs", "cjs", "js"].map((extension) => path.join(directory, `.htmlvalidate.${extension}`)).filter((filePath) => fs2.existsSync(filePath));
}
const defaultResolvers = [esmResolver()];
function hasResolver(value) {
  return Array.isArray(value[0]);
}
class FileSystemConfigLoader extends ConfigLoader {
  cache;
  fs;
  constructor(...args) {
    if (hasResolver(args)) {
      const [resolvers, config, options = {}] = args;
      super(resolvers, config);
      this.fs = /* istanbul ignore next */
      options.fs ?? fs;
    } else {
      const [config, options = {}] = args;
      super(defaultResolvers, config);
      this.fs = /* istanbul ignore next */
      options.fs ?? fs;
    }
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Get configuration for given filename.
   *
   * @param filename - Filename to get configuration for.
   * @param configOverride - Configuration to merge final result with.
   */
  getConfigFor(filename, configOverride) {
    const override = this.loadFromObject(configOverride ?? {});
    if (isThenable(override)) {
      return override.then((override2) => {
        return this._resolveAsync(filename, override2);
      });
    } else {
      return this._resolveSync1(filename, override);
    }
  }
  /**
   * Flush configuration cache.
   *
   * @param filename - If given only the cache for that file is flushed.
   */
  flushCache(filename) {
    if (filename) {
      this.cache.delete(filename);
    } else {
      this.cache.clear();
    }
  }
  /**
   * Load raw configuration from directory traversal.
   *
   * This configuration is not merged with global configuration and may return
   * `null` if no configuration files are found.
   */
  fromFilename(filename) {
    if (filename === "inline") {
      return null;
    }
    const cache = this.cache.get(filename);
    if (cache) {
      return cache;
    }
    let found = false;
    let current = path.resolve(path.dirname(filename));
    let config = this.empty();
    while (true) {
      for (const configFile of findConfigurationFiles(this.fs, current)) {
        const local = this.loadFromFile(configFile);
        if (isThenable(local)) {
          return this.fromFilenameAsync(filename);
        }
        found = true;
        const merged = local.merge(this.resolvers, config);
        if (isThenable(merged)) {
          throw new Error("internal error: async result ended up in sync path");
        }
        config = merged;
      }
      if (config.isRootFound()) {
        break;
      }
      const child = current;
      current = path.dirname(current);
      if (current === child) {
        break;
      }
    }
    if (!found) {
      this.cache.set(filename, null);
      return null;
    }
    this.cache.set(filename, config);
    return config;
  }
  /**
   * Async version of [[fromFilename]].
   *
   * @internal
   */
  async fromFilenameAsync(filename) {
    if (filename === "inline") {
      return null;
    }
    const cache = this.cache.get(filename);
    if (cache) {
      return cache;
    }
    let found = false;
    let current = path.resolve(path.dirname(filename));
    let config = this.empty();
    while (true) {
      for (const configFile of findConfigurationFiles(this.fs, current)) {
        const local = await this.loadFromFile(configFile);
        found = true;
        config = await local.merge(this.resolvers, config);
      }
      if (config.isRootFound()) {
        break;
      }
      const child = current;
      current = path.dirname(current);
      if (current === child) {
        break;
      }
    }
    if (!found) {
      this.cache.set(filename, null);
      return null;
    }
    this.cache.set(filename, config);
    return config;
  }
  _merge(globalConfig, override, config) {
    const merged = config ? config.merge(this.resolvers, override) : globalConfig.merge(this.resolvers, override);
    if (isThenable(merged)) {
      return merged.then((merged2) => {
        return merged2.resolve();
      });
    } else {
      return merged.resolve();
    }
  }
  _resolveSync1(filename, override) {
    if (override.isRootFound()) {
      return override.resolve();
    }
    const globalConfig = this.getGlobalConfig();
    if (isThenable(globalConfig)) {
      return globalConfig.then((globalConfig2) => {
        return this._resolveSync2(filename, override, globalConfig2);
      });
    } else {
      return this._resolveSync2(filename, override, globalConfig);
    }
  }
  _resolveSync2(filename, override, globalConfig) {
    if (globalConfig.isRootFound()) {
      const merged = globalConfig.merge(this.resolvers, override);
      if (isThenable(merged)) {
        return merged.then((merged2) => {
          return merged2.resolve();
        });
      } else {
        return merged.resolve();
      }
    }
    const config = this.fromFilename(filename);
    if (isThenable(config)) {
      return config.then((config2) => {
        return this._merge(globalConfig, override, config2);
      });
    } else {
      return this._merge(globalConfig, override, config);
    }
  }
  async _resolveAsync(filename, override) {
    if (override.isRootFound()) {
      return override.resolve();
    }
    const globalConfig = await this.getGlobalConfig();
    if (globalConfig.isRootFound()) {
      const merged = await globalConfig.merge(this.resolvers, override);
      return merged.resolve();
    }
    const config = await this.fromFilenameAsync(filename);
    return this._merge(globalConfig, override, config);
  }
  /**
   * @internal For testing only
   */
  _getInternalCache() {
    return this.cache;
  }
  defaultConfig() {
    return Config.defaultConfig();
  }
}

const defaults = {
  silent: false,
  version,
  logger(text) {
    console.error(kleur.red(text));
  }
};
function compatibilityCheck(name, declared, options) {
  return compatibilityCheckImpl(name, declared, {
    ...defaults,
    ...options
  });
}

export { FileSystemConfigLoader as F, compatibilityCheck as a, cjsResolver as c, esmResolver as e, legacyRequire as l, nodejsResolver as n };
//# sourceMappingURL=core-nodejs.js.map
